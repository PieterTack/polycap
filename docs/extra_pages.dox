/** \mainpage
 *
 * **Polycap** is a library for C with Python bindings that allows for the simulation of X-ray photons in poly- and monocapillary optics with multi-core processing abilities.
 * This code allows for the study of the influence of the capillary shape, its deviations, surface roughness, reflector material, X-ray energy, source size, distance and divergence on
 * the optic's efficiency, working distance and focal spot size.
 *
 * For each simulated photon, characterized by a three dimensional position, direction and electric field vector, the transmission efficiency through the optic is calculated
 * as a result of a series of reflections within the capillary optic. Additionally, each transmitted photon is characterized by its exit coordinate, direction and electric field vector
 * as well as traveled photon path length within the polycapillary optic. These parameters are saved in an HDF5 output file.
 *
 * At each photon - capillary wall interaction the reflectivity is determined by the Fresnel equation:
 * \f[
	R_{f}(\theta,E) = \left| 
		\frac{\theta - \sqrt{\theta^{2} - 2\delta(E)}}{\theta + \sqrt{\theta^{2} - 2\delta(E)}}
		\right|^{2}
   \f]
 * with \f$\theta\f$ the glancing angle of the incident radiation and  \f$\delta\f$ defined as \f$\delta = \alpha - i\beta\f$ with
 *\f[
	\alpha = \left(\frac{hc}{E}\right)^{2}
		\frac{N_{A}r_{0}\rho}{2\pi}
		\sum\limits_{j=1}^N \frac{w_{j}}{A_{j}} (Z_{j} + f_{j}^{'})
	\\
	\beta = \left(\frac{hc}{E}\right)^{2}
		\frac{N_{A}r_{0}\rho}{2\pi}
		\sum\limits_{j=1}^N \frac{w_{j}}{A_{j}} f_{j}^{"} = \frac{hc}{4\pi} \frac{\mu_{L}}{E}
  \f]
 * Here \f$h\f$ is Planck's constant, \f$c\f$ the light velocity, \f$E\f$ the photon energy, \f$N_{A}\f$ Avogadro's number, \f$r_{0}\f$ the classical electron radius, \f$\rho\f$ the material density, \f$N\f$ the number of elements with weight fraction \f$w_{j}\f$, \f$A_{j}\f$ the atomic weight, \f$Z_{j}\f$ the atomic number and \f$f_{j}\f$ the atomic scattering for element \f$j\f$ and \f$\mu_{L}\f$ the linear attenuation coefficient.
 * By propagating the photon through the capillary and determining the reflectivity at each point a final transmission efficiency, exit coordinate and direction is obtained.
 * This process can then be repeated for multiple photons as a means to simulate an X-ray source with known distance, size and divergence propagating through the capillary optic.
 *
 * \authors Pieter Tack, Tom Schoonjans, Laszlo Vincze
 *
 * \page installation_instructions Installation instructions
 *  
 * \section requirements Requirements
 * \subsection easyrng easyRNG
 * **Polycap** makes use of **easyRNG** when it is installed on the user's device. Alternatively, it will make use of GSL.
 * **easyRNG** is a simple library for C and Fortran providing access to several pseudo-random
 * number generators and pseudo-random number distributions.
 *
 * It doesn't include any implementations of generators or distributions, but is instead a thin wrapper
 * around the \c random templates of the C++ Standard Library that have been defined in the 2011 revision of the C++ standard.
 *
 * The API is modelled after the [GNU Scientific Library (GSL)](https://www.gnu.org/software/gsl/manual/html_node/index.html), and its Fortran bindings [FGSL](http://www.lrz.de/services/software/mathematik/gsl/fortran/).
 * Preliminary tests suggest that easyRNG's performance of its Mersenne Twister random number generators is only slightly worse than its GSL counterparts, but this stronly depends on which implementation of the C++ Standard Library was used.
 * 
 * The main reason to use this library over GSL or FGSL is its license. While GSL and FGSL are covered by the GNU General Public License version 3, easyRNG is available under the 3-clause BSD license, allowing for use in closed-source/commercial software packages.
 *
 * **easyRNG** can only be installed provided the following dependencies are
 * present on your system:
 * - A C++ compiler with full support of the C++11 standard. Compilers known to do the job are recent versions of GCC and clang.
 * - A C compiler (for running `make check`).
 * - Optional: a Fortran compiler with support of the 2003 standard. If not found then the Fortran bindings will not be built.
 * - Optional: GNU Scientific library. When present a test will be run benchmarking easyRNG's C API against GSL.
 * - Optional: Fortran bindings to the GNU Scientific library (FGSL). When present a test will be run benchmarking easyRNG's Fortran API against FGSL.
 *  
 * \subsubsection downloading Downloading easyRNG
 * The source code release tarballs are hosted on the Github repository, in the [releases section](https://github.com/tschoonj/easyRNG/releases).
 * Just get the latest tarball and run the following commands:
 *
 *       tar xfvz easyRNG-x.y.tar.gz
 *       cd easyRNG-x.y
 *       ./configure
 *       make
 *       make check
 *       make install
 *
 *  This procedure is known to work on Linux, Mac OS X and Windows (using [msys2](https://msys2.github.io/))
 *
 *  \subsection downloading Downloading the software
 * 
 *
 *  \subsection head Github repository
 *                                                                                                                    
 *  People interested in running the latest development version will have to clone the Github repository.             
 *  Make sure you have the above mentioned dependencies installed, as well as the GNU autotools (autoconf, automake and libtool).
 *
 *       git clone git@github.com:PieterTack/polycap.git                                                             
 *       cd polycap
 *       autoreconf -i
 *       ./configure
 *       make
 *       make check
 *       make install
 *
 * \page usage Usage
 * 
 * \section c_usage From C/C++/Objective-C
 *
 * Include the easyRNG headers in your code:
 * \code
 * #include <easy_rng.h> // for the random number generators
 * #include <easy_randist.h> // for the random number distributions
 * \endcode
 *
 * Assuming your program source file is called \c program.c, compile it with:
 * \code
 * gcc program.c -o program `pkg-config --cflags --libs easyRNG`
 * \endcode
 *
 * \section fortran_usage From Fortran
 *
 * The Fortran bindings' API is mostly identical to the C's. An important exception here is easy_ran_discrete_preproc(), which has one argument less than its C counterpart.
 * Include the easyRNG module in your code:
 * \code{.f90}
 * USE :: easyRNG
 * \endcode
 *
 * Assuming your program source file is called \c program.f90, compile it with:
 * \code
 * gfortran program.f90 -o program `pkg-config --cflags --libs easyRNG`
 * \endcode
 *
 * Make sure to use the exact same Fortran compiler to compile your program as was used to compile easyRNG!
 *
 * \page examples Examples
 * This page contains the code of the tests I have included to validate the program.
 * The code should be quite straightforward to understand. Comments have been added where deemed useful.
 *
 * \tableofcontents
 *
 * \section test1 Test 1: random number generator C API validation
 * \include test1.c
 * \section test2 Test 2: random number generator C API performance test
 * \include test2.c
 * \section test3 Test 3: random number distributions C API accuracy test
 * \include test3.c
 * \section test4 Test 4: random number generator Fortran API validation
 * \include test4.F90
 * \section test5 Test 5: random number generator Fortran API performance test
 * \include test5.F90
 * \section test6 Test 6: random number distributions Fortran API accuracy test
 * \include test6.F90
 */

